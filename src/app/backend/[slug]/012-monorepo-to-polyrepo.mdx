---
id: '012-monorepo-to-polyrepo'
title: '[Node.js] 모노레포에서 폴리레포로의 여정'
date: '2025-09-02'
description: '조직의 방향성에 맞게 모노레포를 폴리레포로 변환하는 과정에서 겪었던 시행착오와 최종적으로 구현된 아키텍처 완성본'
---

# [Node.js] 모노레포에서 폴리레포로의 여정

기존에 모노레포로 구성되어 있던 백엔드 서비스 코드는, 제가 팀에 합류했을 때 이미 각 서비스 단위로 쪼개져 폴리레포로 분리된 상태였습니다.

하지만 여기에 문제가 있었습니다. 바로 분리 방식이었는데, 모노레포에서 사용하던 공통 로직들을 전부 `from_xxx` 형식으로 Copy & Paste 하여 각 레포에 복사해놓은 기형적인 폴리레포 구조를 띄고 있었습니다. 이러한 코드 구조로는 안정적인 유지보수도, 확장도 어렵다고 판단해 코드 전반을 다시 뜯어보고 리팩토링을 진행하게 됐습니다.

이 글은 그 과정에서 겪은 시행착오와 결국 어떻게 개선했는지를 공유하기 위한 포스팅입니다.

---

## 모노레포와 폴리레포의 정의

#### 모노레포란

여러 서비스(패키지, 모듈 등)를 하나의 Git 저장소에서 함께 관리하는 방식입니다.<br />
독립 실행 가능한 서비스들이 하나의 Git 저장소 안에 함께 존재하며, CLI 커맨드를 통해 각각을 분리 실행할 수 있는 구조를 갖습니다.
<br />

#### 폴리레포란

여러 서비스(패키지, 모듈 등)를 각각의 Git 저장소에 분리해서 관리하는 방식입니다.<br />
독립 실행 가능한 서비스들이 각각의 Git 저장소 안에 존재하며, 각 서비스는 독립적으로 빌드되고 배포될 수 있는 구조를 갖습니다.<br />
이러한 구조를 통해 서비스별로 개발, 배포 주기를 분리할 수 있고, 팀 간 충돌 없이 자율적인 운영이 가능합니다.

---

## 모노레포에서 폴리레포로 전환한 과정 및 결과

기존 서비스 코드는 API와 백그라운드 Worker들이 함께 포함된 모노레포 구조였습니다.
![012-monorepo-to-polyrepo-1.png](/images/012-monorepo-to-polyrepo-1.png)
<br /><br />

하지만 제가 합류했을 당시에는, 아래와 같은 폴리레포 구조로 변경되어 있었습니다.<br />
각 API, Worker 레포지토리에는 공통 로직들이 `from_xxx` 라는 이름으로 Copy & Paste가 되어 있는 상태였습니다.
![012-monorepo-to-polyrepo-2.png](/images/012-monorepo-to-polyrepo-2.png)
위 구조의 가장 큰 단점은 공통 코드 로직을 수정하는 과정이 매우 비효율적이라는 것입니다.<br />
예를 들어, 2차 인증 정책을 변경하려할때 계정계, 채널계 모듈에서 같은 함수를 찾아 중복해서 수정했으며, 이 과정에서 같은 기능을 하는 함수임에도 이름이나 처리 로직 등이 서로 다르게 발전한 경우 코드 수정에 많은 시간을 소요하기도 했습니다.
<br /><br />

따라서 `from_xxx` 로 각자 다르게 발전해 온 코드들을 다시 공통으로 묶어내기 위해, 공통 로직을 담은 NPM 패키지를 만들었고, 아래와 같이 `Common Base`와 `Common`이라는 두 가지 패키지가 탄생했습니다.
```
- Common Base: PgUtil, LogUtil 등 변경 가능성이 거의 없는 공통 로직
- Common: 그 외의 공통 로직
```
![012-monorepo-to-polyrepo-3.png](/images/012-monorepo-to-polyrepo-3.png)
하지만 공통 로직을 패키지화하는 과정에서도 문제가 발생했습니다.<br />
서비스 규모가 커지고 참여하는 개발자가 늘어나면서 Common 패키지의 업데이트 빈도가 높아졌고, 각 레포지토리에서 공통 패키지의 버전을 일관되게 관리하기가 점점 어려워졌습니다.
<br /><br />

이 문제의 원인은 너무 많은 책임을 한곳에 담고 있던 `Common` 패키지라고 판단했습니다. 그래서 자주 변경되는 기능들을 기능 단위로 분리하여 NPM 패키지로 아래와 같이 재구성했습니다.
![012-monorepo-to-polyrepo-4.png](/images/012-monorepo-to-polyrepo-4.png)
하지만 이렇게 분리하면서 또… 새로운 문제가 생겼습니다.

예시로, `slonik`이라는 PSQL 라이브러리를 `기능별 NPM 패키지`로 구성해 두었지만, `Common Base(PgUtil)`에서 이를 사용해야 했기에 결국 해당 패키지를 설치해야 하는 상황이 발생했습니다.<br />
이처럼 `기능별 NPM 패키지`가 `Common Base`에 패키지 안에 포함되면서, 패키지 간의 단방향 의존성이 깨지게 되었습니다.
<br /><br />


이에 따라 `PgUtil`, `LogUtil`와 같은 코어 모듈들을 독립적인 라이브러리로 분리해 리팩토링했으며, 이를 통해 최종적으로 아래와 같이 경계를 명확히한 폴리레포를 구성하게 되었습니다.
![012-monorepo-to-polyrepo-5.png](/images/012-monorepo-to-polyrepo-5.png)
앞으로 운영을 이어가면서 부족한 부분은 점차 보완해 나갈 계획입니다.

---

## 폴리레포 전환에 대한 회고

#### 폴리레포 또는 MSA가 정말 필요할까

모노레포 분리를 고민하고 계시면서, 중소 규모의 개발팀에 계신다면, 꼭 강조하고 싶은 점이 있습니다.<br />

***"잘 설계된 모노레포 아키텍처는 굳이 바꿀 필요가 없다는 것입니다."***
<br />

그럼에도 불구하고 폴리레포로의 전환을 고민하고, 궁극적으로 MSA를 지향하고 계신다면, 아래 조건을 꼭 한번 확인해보셨으면 좋겠습니다.<br />

***"회사가 충분한 성장을 이뤘고, 시간과 비용 측면에서 리팩토링을 감당할 여유가 생겼는가?"***<br />
***"경영 차원에서 독립된 팀 단위의 필요성을 인식했으며, 개발팀이 분리되었을때 독립적으로 운영될 수 있는 구조를 갖출 준비가 되었는가?"***<br />

이 조건을 충족한 상태에서 명확한 WBS와 설계를 바탕으로 프로젝트를 진행하는 것이 바람직하다고 생각합니다.<br />
만약 단순히 `MSA가 좋다` 라는 이유나, `타 팀 또는 경영진의 요청`에 의해 성급히 구조를 바꾸려 한다면, 그 과정은 정말 힘들고 고통스러울 수 있습니다.
<br /><br /><br />


#### 리팩토링을 하면서 느낀점
수 많은 코드를 리팩토링하고 분리하는 과정을 거치면서, 가장 피부에 와닿았던 점은 막연히 중요하다고 들어왔던 `도메인 중심의 사고`, `공통화의 함정`, 그리고 `경계의 중요성`이었습니다.
<br />

**도메인 중심의 사고**
- 단순히 코드 구조를 손보는 것이 아니라, 도메인을 어떻게 모델링했는지에 따라 리팩토링의 난이도와 방향이 크게 달라집니다.
- 공통이라는 이름으로 여러 도메인을 섞어두면, 처음부터 개념적인 분리가 되지 않고 구조를 수정하다가도 자주 막히게 됩니다.

**공통화의 함정**
- 코드를 공통 로직으로 묶는 것은 분명 좋아 보이지만, 비즈니스 로직을 단순히 같다는 이유로 묶다보면 의존성이 꼬이고 유지보수가 더 힘들어집니다.
- 공통화는 늘 신중하게 하고, 때론 중복을 허용하는 것이 나쁜게 아니라는 교훈을 얻었습니다.

**경계의 중요성**
- 하나의 모듈이 지나치게 많은 책임을 지면 변경이 잦아지고, 코드 가독성이 떨어집니다.
- 코드를 리팩토링과 유지보수가 어렵게 느껴질 때는, 먼저 기존 코드의 책임과 경계가 제대로 설정되어 있는지를 점검하는 것이 정말 중요하다는 것을 다시금 깨달았습니다.
