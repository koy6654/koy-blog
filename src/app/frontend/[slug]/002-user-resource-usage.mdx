---
id: '002-user-resource-usage'
title: '[Frontend] 클라이언트가 잡아먹는 사용자의 컴퓨팅 리소스들'
date: '2025-11-01'
description: '클라이언트 개발자가 JS Heap 메모리와 Client-side Storage 등을 활용할때, 사용자 컴퓨터 리소스 중 어떤 것들을 소모시키는지 조사해보기'
---

# [Frontend] 클라이언트가 잡아먹는 사용자의 컴퓨팅 리소스들

백엔드 개발을 할 때는 서버 리소스 사용에 늘 신경을 썼는데, 프론트엔드 개발을 하면서는 사용자의 컴퓨터 리소스 사용에 대해 깊이 고민하지 않았다는 걸 깨달았습니다.

돌아보면 `Redux, React Query` 같은 라이브러리도 그냥 습관적으로 사용해왔지, 실제로 사용자의 메모리나 저장소를 어떻게 활용하는지는 의식하지 않았습니다.

그래서 이번 기회에 프론트엔드 개발 시 사용자의 컴퓨팅 리소스 소모 방식을 정리하고, 제대로 이해한 채로 이를 사용해보고자 합니다.

---

## 클라이언트의 메모리와 저장소의 종류

우선 클라이언트가 자바스크립트에서 접근할 수 있는 메모리와 저장소의 종류에 대해 알아보고, 이들이 사용자 컴퓨터의 어떤 리소스를 사용하는지도 살펴보겠습니다.
<br />

#### JS Heap 메모리

자바스크립트에서 메모리 하면 떠오르는 런타임 메모리(JS Heap)입니다.

`사용자의 RAM`을 리소스로 사용하며, 기본적인 Class 인스턴스 변수, React state, DOM 참조 같은 데이터들이 실시간으로 생성/소멸됩니다.<br />
Garbage Collection이 언제 동작할지 모르기 때문에, 해당 데이터는 개발자 도구의 Memory 탭에서 특정 시점의 Snapshot을 찍어 그 순간 메모리에 어떤 값이 있었는지 확인할 수 있습니다.<br />

일시적인 UI 상태 저장, 컴포넌트 간 데이터 전달 등에 주로 사용됩니다.
<br />

#### Cookies

브라우저에서 가장 오래된 저장 방식으로, 작은 데이터를 key-value 형태로 저장합니다. 서버와 자동으로 주고받을 수 있어 로그인 세션이나 인증 토큰 관리에 널리 쓰입니다.

쿠키는 종류에 따라 저장 리소스가 다릅니다. 세션 쿠키는 `사용자의 RAM`에만 올라가고 브라우저 종료 시 삭제됩니다. 반면, 영속 쿠키(Persistent Cookie)는 `사용자의 Disk`에 기록되어, 브라우저 종료 후에도 만료일이나 사용자가 직접 지우기 전까지 유지됩니다.

세션 유지, 사용자 인증, 간단한 설정 값 전달 등에 주로 사용됩니다.
<br />

#### Session Storage

브라우저 탭 단위로 독립적인 key-value 저장소입니다. 문자열만 저장할 수 있고, 해당 탭이나 창을 닫으면 데이터가 사라집니다. 새로고침은 유지되지만 새 탭에서는 공유되지 않아 임시 세션 데이터 관리에 적합합니다.

Session Storage는 기본적으로 `사용자의 RAM`을 리소스로 활용하는 휘발성 저장소입니다. 다만 일부 브라우저(예: Chromium 계열)는 크래시 복구나 메모리 최적화를 위해 `사용자의 Disk`에 임시 기록을 남기기도 합니다. 그러나 이 경우에도 탭이나 창을 닫으면 데이터는 사라집니다.

로그인 전 임시 폼 데이터, 탭별 UI 상태 관리 등에 주로 사용됩니다.
<br />

#### Local Storage

브라우저에서 가장 흔히 쓰이는 영구 저장소로, key-value 문자열 데이터를 도메인별로 MB 단위까지 저장할 수 있습니다. 직접 지우지 않는 한 남아 있기 때문에 사용자 설정이나 간단한 캐시 데이터를 유지하는 데 자주 사용됩니다.

Local Storage는 항상 `사용자의 Disk`에 기록되며, 브라우저 프로필 DB 파일에 남아 있습니다. 그래서 새로고침이나 브라우저 종료 후에도 그대로 유지됩니다. 다만 동기적 API라 대량 처리 시 성능 저하가 있고, 보안 공격에 취약할 수 있습니다.

사용자 설정 값, 간단한 캐시, 다크 모드 같은 UI 환경 저장 등에 주로 사용됩니다.
<br />

#### IndexedDB

브라우저가 제공하는 대용량 비동기 데이터베이스입니다. 객체를 직접 저장할 수 있고, 트랜잭션을 지원해 NoSQL DB처럼 사용할 수 있습니다. 오프라인 앱이나 수백 MB~GB 규모 데이터를 다루는 경우 주로 쓰입니다.

IndexedDB는 항상 `사용자의 Disk`를 리소스로 사용하여 데이터를 저장하며, 브라우저 내부의 전용 DB 파일을 통해 관리됩니다. 따라서 사용자가 지우지 않는 한 데이터를 안정적으로 보존할 수 있습니다. 다만 API가 복잡해 보통 idb 같은 wrapper 라이브러리를 사용합니다.

오프라인 앱, 대규모 캐시, 검색 가능한 데이터 저장 등에 주로 사용됩니다.
<br />

#### 그 외

아래 저장소들은 일반적인 웹 애플리케이션 개발 과정에서 직접 다룰 일은 많지 않아, 간략히 정리하고 넘어가려 합니다.

- Cache Storage: Service Worker를 통해 네트워크 응답을 `사용자의 Disk`에 캐싱하여 오프라인 지원이나 빠른 로딩을 가능하게 하는 저장소
- Storage Buckets: Chrome에서 실험적으로 도입된 기능으로, 여러 저장소를 묶어 `사용자의 Disk` 할당량과 정리 정책을 세밀하게 제어할 수 있는 스토리지
- Extension Storage: `사용자의 Disk` 또는 Disk+Google 계정(sync)에 데이터를 저장해 확장의 상태와 설정을 유지·동기화하는 브라우저 확장 프로그램 전용 저장소
<br />

#### 요약 및 정리

| 개발자 도구 탭 | 저장소/영역 | 새로고침(F5) | 탭 닫음 | 브라우저 종료 | 사용하는 리소스 |
| --- | --- | --- | --- | --- | --- |
| **Memory** | **휘발성 런타임 메모리** (JS Heap, DOM Nodes, Closure 등) | ❌ 날아감 | ❌ 날아감 | ❌ 날아감 | **RAM (프로세스 메모리)** |
| **Application** | **LocalStorage** | ✅ 유지 | ✅ 유지 | ✅ 유지 | **Disk (브라우저 프로필 DB 파일)** |
| **Application** | **SessionStorage** | ✅ 유지 | ❌ 날아감 | ❌ 날아감 | **RAM (탭 메모리, 일부 브라우저는 임시 Disk 캐시)** |
| **Application** | **Cookies (세션쿠키)** | ✅ 유지 | ❌ 날아감 | ❌ 날아감 | **RAM (프로세스 메모리)** |
| **Application** | **Cookies (만료일 쿠키)** | ✅ 유지 | ✅ 유지 | ✅ 유지 (만료일까지) | **Disk (쿠키 DB 파일)** |
| **Application** | **IndexedDB** | ✅ 유지 | ✅ 유지 | ✅ 유지 | **Disk (IndexedDB 데이터 파일)** |
| **Application** | **Cache Storage (Service Worker)** | ✅ 유지 | ✅ 유지 | ✅ 유지 | **Disk (브라우저 캐시 디렉토리)** |
| **Application** | **Storage Buckets** | ✅ 유지 | ✅ 유지 | ✅ 유지 (quota 정책 적용) | **Disk (전용 스토리지 할당 영역)** |
| **Application** | **Extension Storage (chrome.storage.local/sync)** | ✅ 유지 | ✅ 유지 | ✅ 유지 (정책에 따름) | **Disk (확장 전용 DB/Sync 서버 연동)** |

---

## 범용 라이브러리 분석

React 프레임워크에서 유명한 캐싱 라이브러리들(Redux, React Query 등)이 실제로 어떤 저장소를 사용하는지 궁금해서 확인해보았습니다.

우선 결론부터 말씀드리면, 기본적으로 모두 **JS Heap 메모리**를 사용하며, 별도 라이브러리를 추가로 붙였을 때 **Disk 기반 저장소**를 활용할 수 있었습니다.
<br />

#### Redux

- 기본은 JS Heap에만 상태가 올라가므로 새로고침 시 초기화됨.
- `redux-persist` 같은 라이브러리를 붙이면 localStorage, sessionStorage 등 Disk 영역에 직렬화하여 보관 가능.

#### React Query

- 기본은 JS Heap 위의 in-memory cache이며, 새로고침하면 모두 사라짐.
- `@tanstack/query-persist-client`를 추가하면 localStorage, IndexedDB 등 Disk 영역에 캐시를 저장해 새로고침 후에도 복원 가능.
<br />

정보의 신뢰성을 위해 React Query에서 `stale 기능`에 대해 라이브러리 코드를 직접 분석해보았습니다. `stale 기능`이란 `staleTime` 옵션을 기준으로, **캐싱된 데이터를 그대로 사용할지 / 서버로 요청을 보낼지**를 판별하는 핵심 기능입니다.

아래는 React Query v5 코드 중 일부를 추린 내용입니다.

```tsx
// QueryClient 내부
fetchQuery(options): Promise<TData> {
  const query = this.#queryCache.build(this, options)

  // staleTime 만료 여부 확인
  return query.isStaleByTime(resolveStaleTime(options.staleTime, query))
    ? query.fetch(options) // stale이면 서버 fetch
    : Promise.resolve(query.state.data as TData) // fresh면 JS Heap 값 반환
}

// Query 내부
isStaleByTime(staleTime: StaleTime = 0): boolean {
  if (this.state.data === undefined) return true
  if (staleTime === 'static') return false
  if (this.state.isInvalidated) return true

  // dataUpdatedAt + staleTime 비교
  return !timeUntilStale(this.state.dataUpdatedAt, staleTime)
}
```
<br />

위 분석들을 통해 Client Side Storage의 종류와 각각 사용자 컴퓨터에서 어떤 리소스를 소모하며 캐싱에 활용되는지, 그리고 평소 사용하던 라이브러리들이 어떤 Client Side Storage를 기반으로 동작하는지를 확인할 수 있었습니다.
